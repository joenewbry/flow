"""
Website builder tool for creating sharable webpages from Flow data.
"""

import json
import logging
import os
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional
import markdown
import jinja2

logger = logging.getLogger(__name__)


class WebsiteTool:
    """Tool for creating sharable webpages from Flow data."""
    
    def __init__(self, workspace_root: Path):
        self.workspace_root = workspace_root
        self.website_root = workspace_root / "website-builder"
        self.pages_dir = self.website_root / "pages"
        self.assets_dir = self.website_root / "static" / "assets"
        self.templates_dir = self.website_root / "templates"
        self.static_dir = self.website_root / "static"
        
        # Create directories if they don't exist
        self._setup_directories()
        
        # Initialize Jinja2 environment
        try:
            self.jinja_env = jinja2.Environment(
                loader=jinja2.FileSystemLoader(str(self.templates_dir))
            )
        except Exception as e:
            logger.warning(f"Could not initialize Jinja2: {e}")
            self.jinja_env = None
        
        # Initialize markdown processor
        self.md = markdown.Markdown(extensions=[
            'fenced_code',
            'tables',
            'nl2br',
            'sane_lists'
        ])
        
        logger.info(f"Website tool initialized at {self.website_root}")
    
    def _setup_directories(self):
        """Create necessary directories for the website builder."""
        try:
            self.pages_dir.mkdir(parents=True, exist_ok=True)
            self.assets_dir.mkdir(parents=True, exist_ok=True)
            self.templates_dir.mkdir(parents=True, exist_ok=True)
            (self.static_dir / "css").mkdir(parents=True, exist_ok=True)
            (self.static_dir / "js").mkdir(parents=True, exist_ok=True)
            
            # Create default templates if they don't exist
            self._create_default_templates()
            self._create_default_styles()
            
        except Exception as e:
            logger.error(f"Error setting up directories: {e}")
    
    def _create_default_templates(self):
        """Create default HTML templates if they don't exist."""
        base_template = self.templates_dir / "base.html"
        if not base_template.exists():
            base_html = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }} - Flow</title>
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>{{ title }}</h1>
            <div class="meta">
                <span class="author">{{ author }}</span>
                <span class="date">{{ created_date }}</span>
            </div>
        </div>
    </header>
    
    <main class="container">
        {{ content | safe }}
    </main>
    
    <footer>
        <div class="container">
            <p>Generated by <a href="https://github.com/joenewbry/flow">Flow</a></p>
        </div>
    </footer>
</body>
</html>"""
            base_template.write_text(base_html)
    
    def _create_default_styles(self):
        """Create default CSS if it doesn't exist."""
        css_file = self.static_dir / "css" / "styles.css"
        if not css_file.exists():
            css = """/* Flow Website Builder Styles */
:root {
    --primary-color: #2563eb;
    --secondary-color: #64748b;
    --background-color: #ffffff;
    --text-color: #1e293b;
    --border-color: #e2e8f0;
    --code-background: #f8fafc;
}

@media (prefers-color-scheme: dark) {
    :root {
        --background-color: #0f172a;
        --text-color: #f1f5f9;
        --border-color: #334155;
        --code-background: #1e293b;
    }
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    line-height: 1.6;
    color: var(--text-color);
    background-color: var(--background-color);
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
}

header {
    background: var(--primary-color);
    color: white;
    padding: 2rem 0;
    margin-bottom: 2rem;
}

header h1 {
    margin: 0 0 0.5rem 0;
    font-size: 2.5rem;
}

.meta {
    opacity: 0.9;
    font-size: 0.9rem;
}

.meta span {
    margin-right: 1rem;
}

main {
    min-height: 60vh;
    padding: 2rem 0;
}

main h1, main h2, main h3, main h4, main h5, main h6 {
    margin: 1.5rem 0 1rem 0;
    line-height: 1.3;
}

main p {
    margin: 1rem 0;
}

main img {
    max-width: 100%;
    height: auto;
    border-radius: 8px;
    margin: 1rem 0;
}

main pre {
    background: var(--code-background);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 1rem;
    overflow-x: auto;
    margin: 1rem 0;
}

main code {
    background: var(--code-background);
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
    font-family: 'Monaco', 'Courier New', monospace;
    font-size: 0.9em;
}

main pre code {
    background: transparent;
    padding: 0;
}

main table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
}

main th, main td {
    padding: 0.75rem;
    text-align: left;
    border: 1px solid var(--border-color);
}

main th {
    background: var(--code-background);
    font-weight: 600;
}

main a {
    color: var(--primary-color);
    text-decoration: none;
}

main a:hover {
    text-decoration: underline;
}

main blockquote {
    border-left: 4px solid var(--primary-color);
    padding-left: 1rem;
    margin: 1rem 0;
    color: var(--secondary-color);
}

footer {
    background: var(--code-background);
    border-top: 1px solid var(--border-color);
    padding: 2rem 0;
    margin-top: 4rem;
    text-align: center;
    color: var(--secondary-color);
}

@media (max-width: 768px) {
    header h1 {
        font-size: 2rem;
    }
    
    .container {
        padding: 0 15px;
    }
}
"""
            css_file.write_text(css)
    
    async def create_page(
        self,
        page_name: str,
        title: str,
        content: str,
        author: str = "Flow User",
        include_search_results: bool = False,
        search_data: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """Create a new webpage with the specified content."""
        try:
            # Sanitize page name
            safe_name = "".join(c if c.isalnum() or c in "-_" else "-" for c in page_name.lower())
            
            # Convert markdown to HTML
            html_content = self.md.convert(content)
            
            # If search results are included, add them to the content
            if include_search_results and search_data:
                html_content += self._format_search_results(search_data)
            
            # Render template
            if self.jinja_env:
                try:
                    template = self.jinja_env.get_template("base.html")
                    html = template.render(
                        title=title,
                        author=author,
                        created_date=datetime.now().strftime("%Y-%m-%d %H:%M"),
                        content=html_content
                    )
                except Exception as e:
                    logger.warning(f"Template rendering failed: {e}, using simple HTML")
                    html = self._create_simple_html(title, author, html_content)
            else:
                html = self._create_simple_html(title, author, html_content)
            
            # Save markdown source file
            md_file = self.pages_dir / f"{safe_name}.md"
            md_file.write_text(content)
            
            # Also save HTML for backward compatibility
            html_file = self.pages_dir / f"{safe_name}.html"
            html_file.write_text(html)
            
            return {
                "success": True,
                "page_name": safe_name,
                "local_url": f"http://localhost:8082/page/{safe_name}",
                "md_file": str(md_file),
                "html_file": str(html_file),
                "message": f"Page '{safe_name}' created successfully (saved as .md and .html)"
            }
            
        except Exception as e:
            logger.error(f"Error creating page: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def _create_simple_html(self, title: str, author: str, content: str) -> str:
        """Create simple HTML when templates aren't available."""
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title} - Flow</title>
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>{title}</h1>
            <div class="meta">
                <span class="author">{author}</span>
                <span class="date">{datetime.now().strftime("%Y-%m-%d %H:%M")}</span>
            </div>
        </div>
    </header>
    <main class="container">
        {content}
    </main>
    <footer>
        <div class="container">
            <p>Generated by <a href="https://github.com/joenewbry/flow">Flow</a></p>
        </div>
    </footer>
</body>
</html>"""
    
    def _format_search_results(self, search_data: Dict) -> str:
        """Format search results as HTML."""
        html = "<div class='search-results'><h2>Search Results</h2>"
        
        results = search_data.get("results", [])
        for result in results:
            html += "<div class='result-item'>"
            html += f"<div class='result-timestamp'>{result.get('timestamp', 'N/A')}</div>"
            html += f"<div class='result-text'>{result.get('text', '')}</div>"
            html += "</div>"
        
        html += "</div>"
        return html
    
    async def list_pages(self) -> Dict[str, Any]:
        """List all created pages."""
        try:
            pages = []
            for page_file in self.pages_dir.glob("*.html"):
                stat = page_file.stat()
                pages.append({
                    "name": page_file.stem,
                    "file": page_file.name,
                    "size": stat.st_size,
                    "created": datetime.fromtimestamp(stat.st_ctime).isoformat(),
                    "modified": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                    "url": f"http://localhost:8082/page/{page_file.stem}"
                })
            
            return {
                "success": True,
                "count": len(pages),
                "pages": sorted(pages, key=lambda x: x["modified"], reverse=True)
            }
            
        except Exception as e:
            logger.error(f"Error listing pages: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def delete_page(self, page_name: str) -> Dict[str, Any]:
        """Delete a webpage."""
        try:
            safe_name = "".join(c if c.isalnum() or c in "-_" else "-" for c in page_name.lower())
            page_file = self.pages_dir / f"{safe_name}.html"
            
            if not page_file.exists():
                return {
                    "success": False,
                    "error": f"Page '{safe_name}' not found"
                }
            
            page_file.unlink()
            
            return {
                "success": True,
                "message": f"Page '{safe_name}' deleted successfully"
            }
            
        except Exception as e:
            logger.error(f"Error deleting page: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_page_url(self, page_name: str, ngrok_url: Optional[str] = None) -> Dict[str, Any]:
        """Get the URL for a webpage."""
        try:
            safe_name = "".join(c if c.isalnum() or c in "-_" else "-" for c in page_name.lower())
            page_file = self.pages_dir / f"{safe_name}.html"
            
            if not page_file.exists():
                return {
                    "success": False,
                    "error": f"Page '{safe_name}' not found"
                }
            
            local_url = f"http://localhost:8082/page/{safe_name}"
            
            result = {
                "success": True,
                "page_name": safe_name,
                "local_url": local_url
            }
            
            if ngrok_url:
                # Clean up ngrok URL (remove trailing slash)
                ngrok_url = ngrok_url.rstrip("/")
                result["ngrok_url"] = f"{ngrok_url}/page/{safe_name}"
                result["share_url"] = result["ngrok_url"]
            else:
                result["message"] = "Start ngrok to get a public shareable URL: ngrok http 8082"
            
            return result
            
        except Exception as e:
            logger.error(f"Error getting page URL: {e}")
            return {
                "success": False,
                "error": str(e)
            }


